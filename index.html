<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agentic Financial Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <!-- TradingView Lightweight Charts -->
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
    <!-- Background Effects -->
    <div class="background-effects">
        <div class="gradient-orb orb-1"></div>
        <div class="gradient-orb orb-2"></div>
        <div class="gradient-orb orb-3"></div>
    </div>
    <div class="grid-pattern"></div>

    <!-- Header -->
    <header>
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">üìä</div>
                <div>
                    <h1>Agentic Finance</h1>
                    <span>AI-Powered Analysis</span>
                </div>
            </div>
            <div class="header-actions">
                <div class="status-badge">
                    <div class="status-dot"></div>
                    Agents Online
                </div>
                <button class="theme-toggle" id="theme-toggle" type="button">
                    <span class="theme-icon" id="theme-toggle-icon">üåô</span>
                    <span class="theme-label" id="theme-toggle-label">Light mode</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main>
        <!-- Hero Section -->
        <section class="hero">
            <h2>Intelligent <span>Financial Analysis</span></h2>
            <p>Powered by specialized AI agents for stock analysis and global macro insights. Get comprehensive, data-driven answers in seconds.</p>
        </section>

        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-btn active" data-tab="stock">
                <span class="tab-icon">üìà</span>
                <div>
                    <div>Stock Analysis</div>
                    <small>Ticker lookup & insights</small>
                </div>
            </button>
            <button class="tab-btn" data-tab="macro">
                <span class="tab-icon">üåç</span>
                <div>
                    <div>Global Macro</div>
                    <small>Interest rates, bonds, economy</small>
                </div>
            </button>
            <button class="tab-btn" data-tab="return-calculator">
                <span class="tab-icon">üí∞</span>
                <div>
                    <div>Return Calculator</div>
                    <small>Position returns with FX impact</small>
                </div>
            </button>
        </div>

        <!-- Stock Analysis Panel -->
        <div id="stock-panel" class="analysis-panel active">
            <div class="input-card">
                <div class="input-header">
                    <div class="input-header-icon stock-icon">üìä</div>
                    <div>
                        <h3>Stock Ticker Analysis</h3>
                        <p>Enter a stock ticker to receive comprehensive financial analysis</p>
                    </div>
                </div>
                
                <div class="input-group">
                    <label>Stock Ticker Symbol</label>
                    <div class="input-wrapper">
                        <input type="text" id="stock-ticker" placeholder="e.g., AAPL, MSFT, GOOGL, TSLA or Apple Inc." maxlength="60" autocomplete="off">
                    </div>
                    <div class="quick-select">
                        <span class="quick-chip" data-ticker="AAPL">AAPL</span>
                        <span class="quick-chip" data-ticker="MSFT">MSFT</span>
                        <span class="quick-chip" data-ticker="GOOGL">GOOGL</span>
                        <span class="quick-chip" data-ticker="AMZN">AMZN</span>
                        <span class="quick-chip" data-ticker="NVDA">NVDA</span>
                        <span class="quick-chip" data-ticker="TSLA">TSLA</span>
                        <span class="quick-chip" data-ticker="META">META</span>
                        <span class="quick-chip" data-ticker="JPM">JPM</span>
                    </div>
                    <div class="suggestions-panel" id="ticker-suggestions"></div>
                </div>
                
                <button class="analyze-btn" id="analyze-stock-btn">
                    <span>üîç</span>
                    Analyze Stock
                </button>
            </div>

            <div id="stock-results" class="results-card">
                <div class="results-header">
                    <div class="results-title">
                        <h4 id="stock-results-ticker">Analysis Results</h4>
                        <span class="results-badge">Stock Agent</span>
                    </div>
                    <div class="version-toggle">
                        <button class="version-btn active" data-version="final" title="Flash 3 polished final output">Final</button>
                        <button class="version-btn" data-version="validated" title="MiMo validated/corrected version">Validated</button>
                        <button class="version-btn" data-version="original" title="GPT-OSS raw output">Raw</button>
                    </div>
                    <span class="results-timestamp" id="stock-timestamp"></span>
                </div>
                
                <!-- TradingView Chart Section -->
                <div class="chart-section" id="chart-section">
                    <div class="chart-header">
                        <div class="chart-price-info">
                            <span class="chart-current-price" id="chart-current-price">--</span>
                            <span class="chart-price-change" id="chart-price-change">--</span>
                        </div>
                        <div class="chart-period-selector">
                            <button class="period-btn active" data-period="1mo">1M</button>
                            <button class="period-btn" data-period="3mo">3M</button>
                            <button class="period-btn" data-period="6mo">6M</button>
                            <button class="period-btn" data-period="1y">1Y</button>
                            <button class="period-btn" data-period="2y">2Y</button>
                            <button class="period-btn" data-period="5y">5Y</button>
                        </div>
                    </div>
                    <div class="chart-container" id="stock-chart"></div>
                    <div class="chart-volume-container" id="volume-chart"></div>
                    <div class="chart-attribution">
                        <a href="https://www.tradingview.com/" target="_blank" rel="noopener">
                            üìä Charts by TradingView
                        </a>
                    </div>
                </div>
                
                <div class="results-content" id="stock-analysis"></div>
            </div>
        </div>

        <!-- Macro Analysis Panel -->
        <div id="macro-panel" class="analysis-panel">
            <div class="input-card">
                <div class="input-header">
                    <div class="input-header-icon macro-icon">üåê</div>
                    <div>
                        <h3>Global Macro Outlook</h3>
                        <p>Explore interest rates, bond yields, and economic indicators</p>
                    </div>
                </div>
                
                <div class="input-group">
                    <label>Topic or Question</label>
                    <div class="input-wrapper">
                        <textarea id="macro-topic" placeholder="e.g., What is the current Fed policy outlook? How are bond yields affecting markets?"></textarea>
                    </div>
                    <div class="quick-select">
                        <span class="quick-chip" data-topic="What is the current Federal Reserve policy outlook and interest rate trajectory?">Fed Policy</span>
                        <span class="quick-chip" data-topic="Analyze current US Treasury bond yields and yield curve status">Bond Yields</span>
                        <span class="quick-chip" data-topic="What are the latest inflation indicators and PCE data?">Inflation</span>
                        <span class="quick-chip" data-topic="Analyze current employment data and labor market conditions">Employment</span>
                        <span class="quick-chip" data-topic="What is the current GDP growth outlook?">GDP Growth</span>
                        <span class="quick-chip" data-topic="Analyze the yield curve inversion and recession probability">Yield Curve</span>
                    </div>
                </div>
                
                <button class="analyze-btn" id="analyze-macro-btn">
                    <span>üåç</span>
                    Analyze Macro
                </button>
            </div>

            <div id="macro-results" class="results-card">
                <div class="results-header">
                    <div class="results-title">
                        <h4>Macro Analysis</h4>
                        <span class="results-badge">Macro Agent</span>
                    </div>
                    <div class="version-toggle">
                        <button class="version-btn active" data-version="final" title="Flash 3 polished final output">Final</button>
                        <button class="version-btn" data-version="validated" title="MiMo validated/corrected version">Validated</button>
                        <button class="version-btn" data-version="original" title="GPT-OSS raw output">Raw</button>
                    </div>
                    <span class="results-timestamp" id="macro-timestamp"></span>
                </div>
                <div class="results-content" id="macro-analysis"></div>
            </div>
        </div>

        <!-- Return Calculator Panel -->
        <div id="return-calculator-panel" class="analysis-panel">
            <div class="input-card calculator-card">
                <div class="input-header">
                    <div class="input-header-icon calculator-icon">üí∞</div>
                    <div>
                        <h3>Total Return Calculator</h3>
                        <p>Calculate investment returns with FX impact (USDTHB)</p>
                    </div>
                </div>

                <!-- Ticker Input -->
                <div class="input-group">
                    <label>Stock Ticker</label>
                    <div class="input-wrapper">
                        <input type="text" id="calc-ticker" placeholder="e.g., AAPL, TSLA" maxlength="60" autocomplete="off">
                    </div>
                    <div class="suggestions-panel" id="calc-ticker-suggestions"></div>
                </div>

                <!-- Date Inputs -->
                <div class="input-row">
                    <div class="input-group">
                        <label>Buy Date</label>
                        <input type="date" id="buy-date" class="date-input">
                    </div>
                    <div class="input-group">
                        <label>Sell Date</label>
                        <input type="date" id="sell-date" class="date-input">
                    </div>
                </div>

                <!-- Quantity -->
                <div class="input-group">
                    <label>Quantity (shares)</label>
                    <select id="quantity-input" class="quantity-select">
                        <!-- JavaScript will populate 1-100 -->
                    </select>
                </div>

                <!-- Price Inputs (Auto-populated, Editable) -->
                <div class="input-row">
                    <div class="input-group">
                        <label>Buy Price (USD)</label>
                        <div class="price-input-wrapper">
                            <input type="number" id="buy-price" placeholder="Auto-fetching..." step="0.01" min="0" class="price-input">
                            <span class="price-indicator" id="buy-price-indicator">üîÑ</span>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Sell Price (USD)</label>
                        <div class="price-input-wrapper">
                            <input type="number" id="sell-price" placeholder="Auto-fetching..." step="0.01" min="0" class="price-input">
                            <span class="price-indicator" id="sell-price-indicator">üîÑ</span>
                        </div>
                    </div>
                </div>

                <!-- FX Rate Inputs -->
                <div class="input-row">
                    <div class="input-group">
                        <label>Buy Date FX Rate (USDTHB)</label>
                        <input type="number" id="buy-fx-rate" placeholder="e.g., 33.5" step="0.01" min="0" class="fx-input">
                    </div>
                    <div class="input-group">
                        <label>Sell Date FX Rate (USDTHB)</label>
                        <input type="number" id="sell-fx-rate" placeholder="e.g., 34.2" step="0.01" min="0" class="fx-input">
                    </div>
                </div>

                <button class="analyze-btn calculator-btn" id="calculate-btn">
                    <span>üíπ</span>
                    Calculate Return
                </button>
            </div>

            <!-- Results Card -->
            <div id="calculator-results" class="results-card calculator-results">
                <div class="results-header">
                    <div class="results-title">
                        <h4 id="calc-results-title">Calculation Results</h4>
                        <span class="results-badge calculator-badge">Return Analysis</span>
                    </div>
                    <span class="results-timestamp" id="calc-timestamp"></span>
                </div>

                <div class="results-content" id="calc-results-content">
                    <!-- JavaScript will populate results using safe DOM methods -->
                </div>
            </div>
        </div>

        <!-- Quick Stats -->
        <div class="quick-stats">
            <div class="stat-card" id="stat-fed-rate">
                <div class="stat-icon">üèõÔ∏è</div>
                <div class="stat-label">Fed Funds Rate</div>
                <div class="stat-value">--</div>
            </div>
            <div class="stat-card" id="stat-10y">
                <div class="stat-icon">üìâ</div>
                <div class="stat-label">10Y Treasury</div>
                <div class="stat-value">--</div>
            </div>
            <div class="stat-card" id="stat-inflation">
                <div class="stat-icon">üìä</div>
                <div class="stat-label">CPI YoY</div>
                <div class="stat-value">--</div>
            </div>
            <div class="stat-card" id="stat-vix">
                <div class="stat-icon">‚ö°</div>
                <div class="stat-label">VIX</div>
                <div class="stat-value">--</div>
            </div>
        </div>

        <!-- Correlation Matrix Section -->
        <section class="correlation-section">
            <div class="section-header">
                <div>
                    <h3>Correlation Matrix</h3>
                    <p>Visualize how multiple tickers move together. Enter 2-25 symbols separated by commas or spaces.</p>
                </div>
                <div class="correlation-actions">
                    <label for="correlation-period" class="sr-only">Period</label>
                    <select id="correlation-period" class="correlation-period">
                        <option value="6mo">6M</option>
                        <option value="1y" selected>1Y</option>
                        <option value="2y">2Y</option>
                        <option value="5y">5Y</option>
                    </select>
                    <button class="analyze-btn" id="correlation-btn" type="button">
                        <span>üéØ</span>
                        Build Matrix
                    </button>
                </div>
            </div>

            <div class="input-card correlation-card">
                <div class="input-group">
                    <label for="correlation-tickers">Tickers (comma or space separated)</label>
                    <div class="input-wrapper">
                        <input type="text" id="correlation-tickers" placeholder="AAPL, MSFT, NVDA, AMZN, GOOGL, TSM, AVGO" autocomplete="off">
                    </div>
                    <div class="suggestions-panel" id="correlation-suggestions"></div>
                    <small class="helper-text">Example: AAPL MSFT NVDA TSLA GOOGL | Minimum 2, maximum 25.</small>
                </div>
                <div class="correlation-hints">
                    <span class="hint-chip" data-tickers="AAPL,MSFT,NVDA,AMZN,GOOGL">Mega Tech</span>
                    <span class="hint-chip" data-tickers="XOM,CVX,SHEL,BP">Energy Majors</span>
                    <span class="hint-chip" data-tickers="JPM,BAC,C,GS,MS">US Banks</span>
                    <span class="hint-chip" data-tickers="TSM,ASML,AVGO,AMD">Semis</span>
                </div>
            </div>

            <div id="correlation-results" class="results-card correlation-results">
                <div class="results-header">
                    <div class="results-title">
                        <h4>Correlation Heatmap</h4>
                        <span class="results-badge">Correlation</span>
                    </div>
                    <span class="results-timestamp" id="correlation-asof"></span>
                </div>
                <div id="correlation-grid" class="correlation-grid empty">
                    <p>Enter tickers and click "Build Matrix" to see correlations.</p>
                </div>
                <div id="correlation-warning" class="correlation-warning" style="display: none;"></div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer>
        <p>Built with üß† AI Agents ‚Ä¢ Powered by LangChain & Groq</p>
    </footer>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <script>
        // API Base URL - use relative path to avoid CORS issues
        const API_BASE = '';

        // DOM Elements
        const tabBtns = document.querySelectorAll('.tab-btn');
        const stockPanel = document.getElementById('stock-panel');
        const macroPanel = document.getElementById('macro-panel');
        const returnCalculatorPanel = document.getElementById('return-calculator-panel');
        const stockTickerInput = document.getElementById('stock-ticker');
        const macroTopicInput = document.getElementById('macro-topic');
        const analyzeStockBtn = document.getElementById('analyze-stock-btn');
        const analyzeMacroBtn = document.getElementById('analyze-macro-btn');
        const stockResults = document.getElementById('stock-results');
        const macroResults = document.getElementById('macro-results');
        const stockAnalysis = document.getElementById('stock-analysis');
        const macroAnalysis = document.getElementById('macro-analysis');
        const stockResultsTicker = document.getElementById('stock-results-ticker');
        const stockTimestamp = document.getElementById('stock-timestamp');
        const macroTimestamp = document.getElementById('macro-timestamp');
        const tickerSuggestions = document.getElementById('ticker-suggestions');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const themeIcon = document.getElementById('theme-toggle-icon');
        const themeLabel = document.getElementById('theme-toggle-label');
        const correlationInput = document.getElementById('correlation-tickers');
        const correlationBtn = document.getElementById('correlation-btn');
        const correlationPeriod = document.getElementById('correlation-period');
        const correlationResults = document.getElementById('correlation-results');
        const correlationGrid = document.getElementById('correlation-grid');
        const correlationAsOf = document.getElementById('correlation-asof');
        const correlationWarning = document.getElementById('correlation-warning');
        const correlationSuggestions = document.getElementById('correlation-suggestions');

        const THEME_STORAGE_KEY = 'agentic-finance-theme';
        let suggestionTimer;
        let suggestionController;
        let correlationSuggestionTimer;
        let correlationSuggestionController;
        let ignoreNextInput = false; // Flag to prevent input event after selection
        let ignoreNextCorrelationInput = false; // Flag for correlation input
        let stockSelectedIndex = -1; // Track keyboard-selected suggestion
        let correlationSelectedIndex = -1; // Track correlation keyboard-selected suggestion

        // Store analysis versions for toggling
        let stockAnalysisVersions = {
            final: '',
            validated: '',
            original: ''
        };
        let macroAnalysisVersions = {
            final: '',
            validated: '',
            original: ''
        };

        function applyTheme(theme) {
            const isLight = theme === 'light';
            document.body.classList.toggle('light-mode', isLight);
            if (themeIcon) themeIcon.textContent = isLight ? 'üåû' : 'üåô';
            if (themeLabel) themeLabel.textContent = isLight ? 'Dark mode' : 'Light mode';
        }

        const savedTheme = localStorage.getItem(THEME_STORAGE_KEY) || 'dark';
        applyTheme(savedTheme);

        if (themeToggleBtn) {
            themeToggleBtn.addEventListener('click', () => {
                const nextTheme = document.body.classList.contains('light-mode') ? 'dark' : 'light';
                applyTheme(nextTheme);
                localStorage.setItem(THEME_STORAGE_KEY, nextTheme);
            });
        }

        // Tab Navigation
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                tabBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                const tab = btn.dataset.tab;

                // Hide all panels first
                stockPanel.classList.remove('active');
                macroPanel.classList.remove('active');
                returnCalculatorPanel.classList.remove('active');

                // Show the selected panel
                if (tab === 'stock') {
                    stockPanel.classList.add('active');
                } else if (tab === 'macro') {
                    macroPanel.classList.add('active');
                } else if (tab === 'return-calculator') {
                    returnCalculatorPanel.classList.add('active');
                }

                const correlationSection = document.querySelector(".correlation-section")
                if (correlationSection) {
                    correlationSection.style.display = (tab ==='return-calculator') ? 'none' : 'block';
                }
            });
        });

        // Quick Select Chips - Stock
        document.querySelectorAll('.quick-chip[data-ticker]').forEach(chip => {
            chip.addEventListener('click', () => {
                ignoreNextInput = true;
                stockTickerInput.value = chip.dataset.ticker;
                clearTickerSuggestions();
                setTimeout(() => stockTickerInput.focus(), 50);
            });
        });

        // Quick Select Chips - Macro
        document.querySelectorAll('.quick-chip[data-topic]').forEach(chip => {
            chip.addEventListener('click', () => {
                macroTopicInput.value = chip.dataset.topic;
                macroTopicInput.focus();
            });
        });

        // Show Toast Notification
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };
            
            toast.innerHTML = `<span>${icons[type]}</span><span>${message}</span>`;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }

        // Set Button Loading State
        function setButtonLoading(btn, loading) {
            if (loading) {
                btn.disabled = true;
                btn.innerHTML = '<div class="btn-spinner"></div> Analyzing...';
            } else {
                btn.disabled = false;
                btn.innerHTML = btn.id === 'analyze-stock-btn' 
                    ? '<span>üîç</span> Analyze Stock'
                    : '<span>üåç</span> Analyze Macro';
            }
        }

        // Format Timestamp
        function formatTimestamp(isoString) {
            const date = new Date(isoString);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Format Analysis Text
        function formatAnalysis(text) {
            // Add some basic formatting
            return text
                .replace(/‚Ä¢/g, '<span style="color: var(--accent-cyan);">‚Ä¢</span>')
                .replace(/üìä|üìà|üìâ|üèõÔ∏è|üì∞|‚ö†Ô∏è|‚úÖ|üü¢|üî¥|‚ö™/g, match => `<span style="font-size: 1.2em;">${match}</span>`)
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/__(.*?)__/g, '<em>$1</em>');
        }

        // Correlation helpers
        function parseTickers(input = '') {
            return input
                .split(/[,\s]+/)
                .map(t => t.trim().toUpperCase())
                .filter(Boolean);
        }

        function setCorrelationLoading(loading) {
            if (!correlationBtn) return;
            if (loading) {
                correlationBtn.disabled = true;
                correlationBtn.innerHTML = '<div class="btn-spinner"></div> Building...';
            } else {
                correlationBtn.disabled = false;
                correlationBtn.innerHTML = '<span>üéØ</span> Build Matrix';
            }
        }

        function correlationColor(val) {
            const clamped = Math.max(-1, Math.min(1, Number(val)));
            const hue = ((clamped + 1) / 2) * 120; // -1 red, 0 yellow, 1 green
            return `hsl(${hue}, 70%, 45%)`;
        }

        function renderCorrelationGrid(labels = [], matrix = []) {
            if (!correlationGrid) return;
            if (!labels.length || !matrix.length) {
                correlationGrid.classList.add('empty');
                correlationGrid.innerHTML = '<p>Enter tickers and click "Build Matrix" to see correlations.</p>';
                return;
            }

            const header = `<tr><th></th>${labels.map(l => `<th>${l}</th>`).join('')}</tr>`;
            const rows = matrix
                .map((row, i) => {
                    const cells = row.map((val, j) => {
                        const isDiag = i === j;
                        const num = Number(val);
                        const isNum = Number.isFinite(num);
                        const display = isDiag ? '&nbsp;' : (isNum ? num.toFixed(2) : '‚Äî');
                        const bg = isDiag ? 'var(--bg-primary)' : (isNum ? correlationColor(num) : 'var(--bg-tertiary)');
                        const cls = isDiag ? 'diag' : '';
                        return `<td class="${cls}" style="background:${bg};" title="${labels[i]} vs ${labels[j]}">${display}</td>`;
                    });
                    return `<tr><th>${labels[i]}</th>${cells.join('')}</tr>`;
                })
                .join('');

            correlationGrid.classList.remove('empty');
            correlationGrid.innerHTML = `
                <table class="correlation-table">
                    <thead>${header}</thead>
                    <tbody>${rows}</tbody>
                </table>
            `;
        }

        // Ticker Suggestions
        function clearTickerSuggestions() {
            if (!tickerSuggestions) return;
            tickerSuggestions.innerHTML = '';
            tickerSuggestions.classList.remove('visible');
            stockSelectedIndex = -1;
        }

        function renderTickerSuggestions(items = []) {
            if (!tickerSuggestions) return;
            if (!items.length) {
                clearTickerSuggestions();
                return;
            }
            stockSelectedIndex = -1;
            const markup = items.map((item, index) => `
                <button type="button" class="suggestion-item" data-ticker="${item.ticker}" data-index="${index}">
                    <span class="suggestion-name">${item.company}</span>
                    <span class="suggestion-ticker">${item.ticker}</span>
                </button>
            `).join('');
            tickerSuggestions.innerHTML = markup;
            tickerSuggestions.classList.add('visible');
        }

        function updateStockSuggestionSelection() {
            if (!tickerSuggestions) return;
            const items = tickerSuggestions.querySelectorAll('.suggestion-item');
            items.forEach((item, index) => {
                item.classList.toggle('selected', index === stockSelectedIndex);
            });
            // Scroll selected item into view
            if (stockSelectedIndex >= 0 && items[stockSelectedIndex]) {
                items[stockSelectedIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function selectStockSuggestion(index) {
            const items = tickerSuggestions?.querySelectorAll('.suggestion-item');
            if (!items || !items[index]) return;
            
            ignoreNextInput = true;
            stockTickerInput.value = items[index].dataset.ticker;
            clearTickerSuggestions();
            setTimeout(() => stockTickerInput.focus(), 50);
        }

        async function fetchTickerSuggestions(term) {
            if (!tickerSuggestions) return;
            if (suggestionController) {
                suggestionController.abort();
            }
            suggestionController = new AbortController();
            try {
                const response = await fetch(`${API_BASE}/api/tickers/search?q=${encodeURIComponent(term)}`, {
                    signal: suggestionController.signal
                });
                if (!response.ok) {
                    renderTickerSuggestions([]);
                    return;
                }
                const data = await response.json();
                renderTickerSuggestions(Array.isArray(data) ? data : []);
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.warn('Suggestion error:', error);
                }
            }
        }

        if (stockTickerInput && tickerSuggestions) {
            stockTickerInput.addEventListener('input', () => {
                // Skip if we just selected a suggestion
                if (ignoreNextInput) {
                    ignoreNextInput = false;
                    return;
                }

                const value = stockTickerInput.value.trim();
                if (value.length < 2) {
                    clearTickerSuggestions();
                    return;
                }
                clearTimeout(suggestionTimer);
                suggestionTimer = setTimeout(() => fetchTickerSuggestions(value), 200);
            });

            stockTickerInput.addEventListener('focus', () => {
                // Don't re-fetch if we just selected a suggestion
                if (ignoreNextInput) return;

                const value = stockTickerInput.value.trim();
                if (value.length >= 2 && !tickerSuggestions.classList.contains('visible')) {
                    fetchTickerSuggestions(value);
                }
            });

            stockTickerInput.addEventListener('keydown', (event) => {
                const isVisible = tickerSuggestions.classList.contains('visible');
                const items = tickerSuggestions.querySelectorAll('.suggestion-item');
                const itemCount = items.length;
                
                if (event.key === 'Escape') {
                    clearTickerSuggestions();
                    return;
                }
                
                if (!isVisible || itemCount === 0) return;
                
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    stockSelectedIndex = stockSelectedIndex < itemCount - 1 ? stockSelectedIndex + 1 : 0;
                    updateStockSuggestionSelection();
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    stockSelectedIndex = stockSelectedIndex > 0 ? stockSelectedIndex - 1 : itemCount - 1;
                    updateStockSuggestionSelection();
                } else if (event.key === 'Enter') {
                    event.preventDefault();
                    if (stockSelectedIndex >= 0) {
                        selectStockSuggestion(stockSelectedIndex);
                    }
                }
            });

            tickerSuggestions.addEventListener('click', (event) => {
                const target = event.target.closest('.suggestion-item');
                if (!target) return;

                // Set flag to ignore the next input event (triggered by value change)
                ignoreNextInput = true;

                stockTickerInput.value = target.dataset.ticker;
                clearTickerSuggestions();

                // Small delay before focus to ensure suggestions are fully cleared
                setTimeout(() => {
                    stockTickerInput.focus();
                }, 50);
            });

            document.addEventListener('click', (event) => {
                if (!tickerSuggestions.contains(event.target) && event.target !== stockTickerInput) {
                    clearTickerSuggestions();
                }
            });
        }

        // ========== CORRELATION TICKER SUGGESTIONS ==========
        function clearCorrelationSuggestions() {
            if (!correlationSuggestions) return;
            correlationSuggestions.innerHTML = '';
            correlationSuggestions.classList.remove('visible');
            correlationSelectedIndex = -1;
        }

        function renderCorrelationSuggestions(items = []) {
            if (!correlationSuggestions) return;
            if (!items.length) {
                clearCorrelationSuggestions();
                return;
            }
            correlationSelectedIndex = -1;
            const markup = items.map((item, index) => `
                <button type="button" class="suggestion-item" data-ticker="${item.ticker}" data-index="${index}">
                    <span class="suggestion-name">${item.company}</span>
                    <span class="suggestion-ticker">${item.ticker}</span>
                </button>
            `).join('');
            correlationSuggestions.innerHTML = markup;
            correlationSuggestions.classList.add('visible');
        }

        function updateCorrelationSuggestionSelection() {
            if (!correlationSuggestions) return;
            const items = correlationSuggestions.querySelectorAll('.suggestion-item');
            items.forEach((item, index) => {
                item.classList.toggle('selected', index === correlationSelectedIndex);
            });
            if (correlationSelectedIndex >= 0 && items[correlationSelectedIndex]) {
                items[correlationSelectedIndex].scrollIntoView({ block: 'nearest' });
            }
        }

        function selectCorrelationSuggestion(index) {
            const items = correlationSuggestions?.querySelectorAll('.suggestion-item');
            if (!items || !items[index]) return;
            
            ignoreNextCorrelationInput = true;
            const selectedTicker = items[index].dataset.ticker;
            const currentValue = correlationInput.value;
            const newValue = replaceLastWord(currentValue, selectedTicker) + ', ';
            correlationInput.value = newValue;
            clearCorrelationSuggestions();
            setTimeout(() => correlationInput.focus(), 50);
        }

        async function fetchCorrelationSuggestions(term) {
            if (!correlationSuggestions) return;
            if (correlationSuggestionController) {
                correlationSuggestionController.abort();
            }
            correlationSuggestionController = new AbortController();
            try {
                const response = await fetch(`${API_BASE}/api/tickers/search?q=${encodeURIComponent(term)}`, {
                    signal: correlationSuggestionController.signal
                });
                if (!response.ok) {
                    renderCorrelationSuggestions([]);
                    return;
                }
                const data = await response.json();
                renderCorrelationSuggestions(Array.isArray(data) ? data : []);
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.warn('Correlation suggestion error:', error);
                }
            }
        }

        // Get the last word being typed (after comma or space)
        function getLastWord(input) {
            const parts = input.split(/[,\s]+/);
            return parts[parts.length - 1] || '';
        }

        // Replace the last word with the selected ticker
        function replaceLastWord(input, newTicker) {
            const parts = input.split(/([,\s]+)/);
            // Find and replace the last non-separator part
            for (let i = parts.length - 1; i >= 0; i--) {
                if (parts[i].trim() && !/^[,\s]+$/.test(parts[i])) {
                    parts[i] = newTicker;
                    break;
                }
            }
            return parts.join('');
        }

        if (correlationInput && correlationSuggestions) {
            correlationInput.addEventListener('input', () => {
                if (ignoreNextCorrelationInput) {
                    ignoreNextCorrelationInput = false;
                    return;
                }

                const lastWord = getLastWord(correlationInput.value);
                if (lastWord.length < 2) {
                    clearCorrelationSuggestions();
                    return;
                }
                clearTimeout(correlationSuggestionTimer);
                correlationSuggestionTimer = setTimeout(() => fetchCorrelationSuggestions(lastWord), 200);
            });

            correlationInput.addEventListener('focus', () => {
                if (ignoreNextCorrelationInput) return;
                const lastWord = getLastWord(correlationInput.value);
                if (lastWord.length >= 2 && !correlationSuggestions.classList.contains('visible')) {
                    fetchCorrelationSuggestions(lastWord);
                }
            });

            correlationInput.addEventListener('keydown', (event) => {
                const isVisible = correlationSuggestions.classList.contains('visible');
                const items = correlationSuggestions.querySelectorAll('.suggestion-item');
                const itemCount = items.length;
                
                if (event.key === 'Escape') {
                    clearCorrelationSuggestions();
                    return;
                }
                
                if (!isVisible || itemCount === 0) return;
                
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    correlationSelectedIndex = correlationSelectedIndex < itemCount - 1 ? correlationSelectedIndex + 1 : 0;
                    updateCorrelationSuggestionSelection();
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    correlationSelectedIndex = correlationSelectedIndex > 0 ? correlationSelectedIndex - 1 : itemCount - 1;
                    updateCorrelationSuggestionSelection();
                } else if (event.key === 'Enter') {
                    event.preventDefault();
                    if (correlationSelectedIndex >= 0) {
                        selectCorrelationSuggestion(correlationSelectedIndex);
                    }
                }
            });

            correlationSuggestions.addEventListener('click', (event) => {
                const target = event.target.closest('.suggestion-item');
                if (!target) return;

                ignoreNextCorrelationInput = true;
                const selectedTicker = target.dataset.ticker;
                
                // Replace the last word with the selected ticker and add comma+space
                const currentValue = correlationInput.value;
                const newValue = replaceLastWord(currentValue, selectedTicker) + ', ';
                correlationInput.value = newValue;
                
                clearCorrelationSuggestions();
                setTimeout(() => correlationInput.focus(), 50);
            });

            document.addEventListener('click', (event) => {
                if (!correlationSuggestions.contains(event.target) && event.target !== correlationInput) {
                    clearCorrelationSuggestions();
                }
            });
        }

        // Analyze Stock
        analyzeStockBtn.addEventListener('click', async () => {
            const tickerInputValue = stockTickerInput.value.trim();

            if (!tickerInputValue) {
                showToast('Please enter a stock ticker', 'warning');
                return;
            }

            setButtonLoading(analyzeStockBtn, true);
            stockResults.classList.remove('visible');
            clearTickerSuggestions();

            try {
                const response = await fetch(`${API_BASE}/api/analyze/stock`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ ticker: tickerInputValue })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Analysis failed');
                }

                const data = await response.json();

                // Store all analysis versions for toggle buttons
                stockAnalysisVersions.final = data.analysis || '';
                stockAnalysisVersions.validated = data.validatedAnalysis || data.analysis || '';
                stockAnalysisVersions.original = data.originalAnalysis || data.analysis || '';

                // Log for debugging
                console.log('Stock versions stored:', {
                    final: stockAnalysisVersions.final?.substring(0, 100),
                    validated: stockAnalysisVersions.validated?.substring(0, 100),
                    original: stockAnalysisVersions.original?.substring(0, 100)
                });

                const label = data.displayName ? `${data.displayName} (${data.ticker})` : data.ticker;
                stockResultsTicker.textContent = `${label} Analysis`;
                stockTimestamp.textContent = formatTimestamp(data.timestamp);
                stockAnalysis.innerHTML = formatAnalysis(stockAnalysisVersions.final);

                // Reset version toggle to "Final"
                document.querySelectorAll('#stock-results .version-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.version === 'final');
                });

                stockResults.classList.add('visible');

                showToast(`Analysis complete for ${label}`, 'success');

            } catch (error) {
                console.error('Error:', error);
                showToast(error.message || 'Failed to analyze stock. Please try again.', 'error');
            } finally {
                setButtonLoading(analyzeStockBtn, false);
            }
        });

        // Analyze Macro
        analyzeMacroBtn.addEventListener('click', async () => {
            const topic = macroTopicInput.value.trim();

            if (!topic) {
                showToast('Please enter a topic or question', 'warning');
                return;
            }

            setButtonLoading(analyzeMacroBtn, true);
            macroResults.classList.remove('visible');

            try {
                const response = await fetch(`${API_BASE}/api/analyze/macro`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ topic })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Analysis failed');
                }

                const data = await response.json();

                // Store all analysis versions
                macroAnalysisVersions.final = data.analysis || '';
                macroAnalysisVersions.validated = data.validatedAnalysis || data.analysis || '';
                macroAnalysisVersions.original = data.originalAnalysis || data.analysis || '';

                // Log for debugging
                console.log('Macro versions stored:', {
                    final: macroAnalysisVersions.final?.substring(0, 100),
                    validated: macroAnalysisVersions.validated?.substring(0, 100),
                    original: macroAnalysisVersions.original?.substring(0, 100)
                });

                macroTimestamp.textContent = formatTimestamp(data.timestamp);
                macroAnalysis.innerHTML = formatAnalysis(macroAnalysisVersions.final);

                // Reset version toggle to "Final"
                document.querySelectorAll('#macro-results .version-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.version === 'final');
                });

                macroResults.classList.add('visible');

                showToast('Macro analysis complete', 'success');

            } catch (error) {
                console.error('Error:', error);
                showToast('Failed to analyze macro topic. Please try again.', 'error');
            } finally {
                setButtonLoading(analyzeMacroBtn, false);
            }
        });

        // Version Toggle Functionality
        document.addEventListener('click', (event) => {
            const versionBtn = event.target.closest('.version-btn');
            if (!versionBtn) return;

            const version = versionBtn.dataset.version;
            const resultsCard = versionBtn.closest('.results-card');

            // Determine if this is stock or macro
            const isStock = resultsCard.id === 'stock-results';
            const analysisEl = isStock ? stockAnalysis : macroAnalysis;
            const versions = isStock ? stockAnalysisVersions : macroAnalysisVersions;

            // Debug logging
            console.log('Version toggle clicked:', {
                version,
                isStock,
                hasContent: {
                    final: !!versions.final,
                    validated: !!versions.validated,
                    original: !!versions.original
                },
                contentLengths: {
                    final: versions.final?.length || 0,
                    validated: versions.validated?.length || 0,
                    original: versions.original?.length || 0
                }
            });

            // Update active state
            resultsCard.querySelectorAll('.version-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            versionBtn.classList.add('active');

            // Display the selected version
            const content = versions[version] || versions.final || '';
            console.log('Displaying content (first 200 chars):', content?.substring(0, 200));
            analysisEl.innerHTML = formatAnalysis(content);

            // Show toast with version info
            const versionLabels = {
                'final': 'Final (Flash 3 Polished)',
                'validated': 'Validated (MiMo Corrected)',
                'original': 'Raw (GPT-OSS Output)'
            };
            showToast(`Showing ${versionLabels[version]}`, 'info');
        });

        // Correlation Matrix
        async function buildCorrelationMatrix() {
            if (!correlationInput) return;
            const tickers = parseTickers(correlationInput.value);
            const period = correlationPeriod ? correlationPeriod.value : '1y';

            if (tickers.length < 2) {
                showToast('Please enter at least two tickers', 'warning');
                return;
            }

            setCorrelationLoading(true);
            if (correlationResults) correlationResults.classList.remove('visible');
            if (correlationWarning) correlationWarning.style.display = 'none';

            try {
                const response = await fetch(`${API_BASE}/api/correlation`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tickers, period })
                });

                const data = await response.json();
                if (!response.ok || data.error) {
                    throw new Error(data.error || 'Failed to compute correlation');
                }

                renderCorrelationGrid(data.tickers, data.matrix);

                if (correlationAsOf) {
                    const periodLabel = data.period ? ` ‚Ä¢ ${data.period.toUpperCase()}` : '';
                    correlationAsOf.textContent = data.asOf ? `As of ${data.asOf}${periodLabel}` : '';
                }

                if (correlationWarning) {
                    if (data.warnings && data.warnings.length) {
                        correlationWarning.style.display = 'block';
                        correlationWarning.textContent = `Unrecognized entries (used as-is): ${data.warnings.join(', ')}`;
                    } else {
                        correlationWarning.style.display = 'none';
                    }
                }

                if (correlationResults) correlationResults.classList.add('visible');
                showToast('Correlation matrix updated', 'success');
            } catch (error) {
                console.error('Correlation error:', error);
                showToast(error.message || 'Unable to build correlation matrix', 'error');
            } finally {
                setCorrelationLoading(false);
            }
        }

        if (correlationBtn) {
            correlationBtn.addEventListener('click', buildCorrelationMatrix);
        }

        if (correlationInput) {
            correlationInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    buildCorrelationMatrix();
                }
            });
        }

        if (correlationInput) {
            document.querySelectorAll('.hint-chip[data-tickers]').forEach(chip => {
                chip.addEventListener('click', () => {
                    correlationInput.value = chip.dataset.tickers.replace(/,/g, ', ');
                    correlationInput.focus();
                });
            });
        }

        // Ensure correlation results are hidden initially
        if (correlationResults) {
            correlationResults.classList.remove('visible');
        }

        // Load Quick Stats on Page Load
        async function loadQuickStats() {
            try {
                const response = await fetch(`${API_BASE}/api/quick/indicators/general`);
                if (response.ok) {
                    const data = await response.json();
                    const text = data.indicators;
                    
                    // Parse indicators from text
                    const fedMatch = text.match(/Federal Funds Rate:\s*([\d.]+)%/);
                    const treasuryMatch = text.match(/10-Year Treasury:\s*([\d.]+)%/);
                    const cpiMatch = text.match(/CPI.*?:\s*([\d.]+)%/);
                    const vixMatch = text.match(/VIX:\s*([\d.]+)%/);
                    
                    if (fedMatch) {
                        document.querySelector('#stat-fed-rate .stat-value').textContent = fedMatch[1] + '%';
                    }
                    if (treasuryMatch) {
                        document.querySelector('#stat-10y .stat-value').textContent = treasuryMatch[1] + '%';
                    }
                    if (cpiMatch) {
                        document.querySelector('#stat-inflation .stat-value').textContent = cpiMatch[1] + '%';
                    }
                    if (vixMatch) {
                        document.querySelector('#stat-vix .stat-value').textContent = vixMatch[1];
                    }
                }
            } catch (error) {
                console.log('Could not load quick stats:', error);
            }
        }

        // Keyboard shortcuts
        stockTickerInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                analyzeStockBtn.click();
            }
        });

        macroTopicInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                analyzeMacroBtn.click();
            }
        });

        // ========== TradingView Lightweight Charts ==========
        let mainChart = null;
        let volumeChart = null;
        let candleSeries = null;
        let volumeSeries = null;
        let currentChartTicker = null;

        function getChartColors() {
            const isLight = document.body.classList.contains('light-mode');
            return {
                background: isLight ? '#ffffff' : '#12121a',
                textColor: isLight ? '#333333' : '#a0a0b0',
                gridColor: isLight ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)',
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderUpColor: '#26a69a',
                borderDownColor: '#ef5350',
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
            };
        }

        function initChart() {
            const chartContainer = document.getElementById('stock-chart');
            const volumeContainer = document.getElementById('volume-chart');
            
            if (!chartContainer || !volumeContainer || !window.LightweightCharts) {
                console.warn('Chart containers or library not found');
                return;
            }

            // Clear existing charts
            if (mainChart) {
                mainChart.remove();
                mainChart = null;
            }
            if (volumeChart) {
                volumeChart.remove();
                volumeChart = null;
            }

            const colors = getChartColors();

            // Create main price chart
            mainChart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: 350,
                layout: {
                    background: { type: 'solid', color: colors.background },
                    textColor: colors.textColor,
                },
                grid: {
                    vertLines: { color: colors.gridColor },
                    horzLines: { color: colors.gridColor },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: colors.gridColor,
                },
                timeScale: {
                    borderColor: colors.gridColor,
                    timeVisible: true,
                    secondsVisible: false,
                },
                handleScroll: { vertTouchDrag: false },
            });

            // Add candlestick series
            candleSeries = mainChart.addSeries(LightweightCharts.CandlestickSeries, {
                upColor: colors.upColor,
                downColor: colors.downColor,
                borderUpColor: colors.borderUpColor,
                borderDownColor: colors.borderDownColor,
                wickUpColor: colors.wickUpColor,
                wickDownColor: colors.wickDownColor,
            });

            // Create volume chart
            volumeChart = LightweightCharts.createChart(volumeContainer, {
                width: volumeContainer.clientWidth,
                height: 80,
                layout: {
                    background: { type: 'solid', color: colors.background },
                    textColor: colors.textColor,
                },
                grid: {
                    vertLines: { visible: false },
                    horzLines: { visible: false },
                },
                rightPriceScale: {
                    borderColor: colors.gridColor,
                    scaleMargins: { top: 0.1, bottom: 0 },
                },
                timeScale: {
                    visible: false,
                },
                handleScroll: { vertTouchDrag: false },
            });

            // Add volume series
            volumeSeries = volumeChart.addSeries(LightweightCharts.HistogramSeries, {
                priceFormat: { type: 'volume' },
                priceScaleId: '',
            });

            // Sync the time scales
            mainChart.timeScale().subscribeVisibleLogicalRangeChange((range) => {
                if (range && volumeChart) {
                    volumeChart.timeScale().setVisibleLogicalRange(range);
                }
            });

            volumeChart.timeScale().subscribeVisibleLogicalRangeChange((range) => {
                if (range && mainChart) {
                    mainChart.timeScale().setVisibleLogicalRange(range);
                }
            });

            // Handle resize
            const resizeObserver = new ResizeObserver(entries => {
                if (mainChart && volumeChart) {
                    const { width } = entries[0].contentRect;
                    mainChart.applyOptions({ width });
                    volumeChart.applyOptions({ width });
                }
            });
            resizeObserver.observe(chartContainer);

            return { mainChart, volumeChart, candleSeries, volumeSeries };
        }

        async function loadChartData(ticker, period = '1y') {
            const chartSection = document.getElementById('chart-section');
            const chartContainer = document.getElementById('stock-chart');
            const priceEl = document.getElementById('chart-current-price');
            const changeEl = document.getElementById('chart-price-change');

            if (!chartSection) return;

            // Initialize chart on first load
            const isFirstLoad = !mainChart || !candleSeries;
            if (isFirstLoad) {
                chartContainer.innerHTML = '<div class="chart-loading">üìä Loading chart data...</div>';
            }

            try {
                // Show loading on price display for quick feedback
                if (priceEl && !isFirstLoad) {
                    priceEl.style.opacity = '0.5';
                }

                const response = await fetch(`${API_BASE}/api/chart/${ticker}?period=${period}`);
                if (!response.ok) {
                    throw new Error('Failed to load chart data');
                }

                const data = await response.json();

                // Initialize chart only on first load
                if (isFirstLoad) {
                    chartContainer.innerHTML = '';
                    initChart();
                }

                // Update chart data efficiently
                if (candleSeries && data.candles && data.candles.length > 0) {
                    candleSeries.setData(data.candles);
                }

                if (volumeSeries && data.volume && data.volume.length > 0) {
                    volumeSeries.setData(data.volume);
                }

                // Fit content smoothly
                if (mainChart) {
                    mainChart.timeScale().fitContent();
                }
                if (volumeChart) {
                    volumeChart.timeScale().fitContent();
                }

                // Update price display
                if (priceEl) {
                    priceEl.textContent = `$${data.currentPrice.toFixed(2)}`;
                    priceEl.style.opacity = '1';
                }

                if (changeEl) {
                    const isPositive = data.priceChange >= 0;
                    const sign = isPositive ? '+' : '';
                    changeEl.textContent = `${sign}$${data.priceChange.toFixed(2)} (${sign}${data.priceChangePct.toFixed(2)}%)`;
                    changeEl.className = `chart-price-change ${isPositive ? 'positive' : 'negative'}`;
                }

                currentChartTicker = ticker;

            } catch (error) {
                console.error('Chart loading error:', error);
                if (isFirstLoad) {
                    chartContainer.innerHTML = '<div class="chart-loading">‚ö†Ô∏è Could not load chart data</div>';
                } else {
                    showToast('Failed to update chart', 'error');
                }
                if (priceEl) {
                    priceEl.style.opacity = '1';
                }
            }
        }

        // Period selector buttons
        document.querySelectorAll('.period-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                if (!currentChartTicker) return;

                // Prevent double-clicks
                if (btn.disabled) return;

                // Update active state
                document.querySelectorAll('.period-btn').forEach(b => {
                    b.classList.remove('active');
                    b.disabled = false;
                });
                btn.classList.add('active');
                btn.disabled = true;

                // Reload chart with new period
                await loadChartData(currentChartTicker, btn.dataset.period);

                // Re-enable button
                btn.disabled = false;
            });
        });

        // Update chart colors when theme changes
        if (themeToggleBtn) {
            const originalThemeClick = themeToggleBtn.onclick;
            themeToggleBtn.addEventListener('click', () => {
                // Re-initialize chart with new colors after theme change
                setTimeout(() => {
                    if (currentChartTicker && mainChart) {
                        const colors = getChartColors();
                        mainChart.applyOptions({
                            layout: {
                                background: { type: 'solid', color: colors.background },
                                textColor: colors.textColor,
                            },
                            grid: {
                                vertLines: { color: colors.gridColor },
                                horzLines: { color: colors.gridColor },
                            },
                        });
                        if (volumeChart) {
                            volumeChart.applyOptions({
                                layout: {
                                    background: { type: 'solid', color: colors.background },
                                    textColor: colors.textColor,
                                },
                            });
                        }
                    }
                }, 100);
            });
        }

        // Modify stock analysis to also load chart
        const originalAnalyzeClick = analyzeStockBtn.onclick;
        analyzeStockBtn.addEventListener('click', async () => {
            // Wait a moment for the analysis to start, then load chart
            setTimeout(async () => {
                const tickerValue = stockTickerInput.value.trim();
                if (tickerValue) {
                    // Try to resolve ticker from input
                    try {
                        const resolveResponse = await fetch(`${API_BASE}/api/tickers/search?q=${encodeURIComponent(tickerValue)}`);
                        if (resolveResponse.ok) {
                            const matches = await resolveResponse.json();
                            const ticker = matches.length > 0 ? matches[0].ticker : tickerValue.toUpperCase();
                            loadChartData(ticker, '1y');
                            // Reset period selector to 1Y
                            document.querySelectorAll('.period-btn').forEach(b => {
                                b.classList.toggle('active', b.dataset.period === '1y');
                            });
                        }
                    } catch (e) {
                        loadChartData(tickerValue.toUpperCase(), '1y');
                    }
                }
            }, 500);
        });

        // ============================================
        // RETURN CALCULATOR FUNCTIONALITY
        // ============================================

        // HTML escape helper (for security)
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // Create element with text content safely
        function createElementWithText(tag, text, className) {
            const el = document.createElement(tag);
            if (className) el.className = className;
            if (text) el.textContent = text;
            return el;
        }

        // Populate quantity dropdown (1-100)
        const quantitySelect = document.getElementById('quantity-input');
        if (quantitySelect) {
            for (let i = 1; i <= 100; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                if (i === 10) option.selected = true;  // Default to 10
                quantitySelect.appendChild(option);
            }
        }

        // Calculator DOM elements
        const calcTickerInput = document.getElementById('calc-ticker');
        const calcTickerSuggestions = document.getElementById('calc-ticker-suggestions');
        const buyDateInput = document.getElementById('buy-date');
        const sellDateInput = document.getElementById('sell-date');
        const buyPriceInput = document.getElementById('buy-price');
        const sellPriceInput = document.getElementById('sell-price');
        const buyPriceIndicator = document.getElementById('buy-price-indicator');
        const sellPriceIndicator = document.getElementById('sell-price-indicator');
        const calculateBtn = document.getElementById('calculate-btn');
        const calculatorResults = document.getElementById('calculator-results');
        const calcResultsContent = document.getElementById('calc-results-content');
        const calcTimestamp = document.getElementById('calc-timestamp');
        const calcResultsTitle = document.getElementById('calc-results-title');

        let calcSuggestionTimer = null;
        let calcAbortController = null;
        let buyPriceOverridden = false;
        let sellPriceOverridden = false;
        let priceFetchTimer = null;

        // Ticker autocomplete for calculator
        if (calcTickerInput && calcTickerSuggestions) {
            calcTickerInput.addEventListener('input', () => {
                const value = calcTickerInput.value.trim();
                if (value.length < 2) {
                    calcTickerSuggestions.textContent = '';
                    calcTickerSuggestions.classList.remove('visible');
                    return;
                }

                clearTimeout(calcSuggestionTimer);
                calcSuggestionTimer = setTimeout(() => fetchCalcTickerSuggestions(value), 200);
            });

            calcTickerInput.addEventListener('change', () => {
                buyPriceOverridden = false;
                sellPriceOverridden = false;
                if (buyPriceInput) buyPriceInput.value = '';
                if (sellPriceInput) sellPriceInput.value = '';
                if (buyPriceIndicator) {
                    buyPriceIndicator.textContent = 'üîÑ';
                    buyPriceIndicator.title = 'Auto-fetch';
                }
                if (sellPriceIndicator) {
                    sellPriceIndicator.textContent = 'üîÑ';
                    sellPriceIndicator.title = 'Auto-fetch';
                }
            });
        }

        async function fetchCalcTickerSuggestions(query) {
            if (calcAbortController) calcAbortController.abort();
            calcAbortController = new AbortController();

            try {
                const response = await fetch(`${API_BASE}/api/tickers/search?q=${encodeURIComponent(query)}`, {
                    signal: calcAbortController.signal
                });
                const suggestions = await response.json();
                renderCalcTickerSuggestions(suggestions);
            } catch (error) {
                if (error.name !== 'AbortError') console.error('Suggestion fetch error:', error);
            }
        }

        function renderCalcTickerSuggestions(suggestions) {
            if (!calcTickerSuggestions) return;
            calcTickerSuggestions.textContent = '';

            if (!suggestions || suggestions.length === 0) {
                calcTickerSuggestions.classList.remove('visible');
                return;
            }

            suggestions.forEach(s => {
                const btn = document.createElement('button');
                btn.className = 'suggestion-item';
                btn.dataset.ticker = s.ticker;

                const strong = document.createElement('strong');
                strong.textContent = s.ticker;
                btn.appendChild(strong);
                btn.appendChild(document.createTextNode(' - ' + s.company));

                btn.addEventListener('click', () => {
                    calcTickerInput.value = s.ticker;
                    calcTickerSuggestions.classList.remove('visible');
                    fetchPricesForDates();
                });

                calcTickerSuggestions.appendChild(btn);
            });

            calcTickerSuggestions.classList.add('visible');
        }

        // Close calculator suggestions when clicking outside
        if (calcTickerInput && calcTickerSuggestions) {
            document.addEventListener('click', (event) => {
                if (!calcTickerSuggestions.contains(event.target) && event.target !== calcTickerInput) {
                    calcTickerSuggestions.classList.remove('visible');
                }
            });
        }

        // Track manual price edits
        if (buyPriceInput) {
            buyPriceInput.addEventListener('input', () => {
                if (buyPriceInput.value) {
                    buyPriceOverridden = true;
                    if (buyPriceIndicator) {
                        buyPriceIndicator.textContent = '‚úèÔ∏è';
                        buyPriceIndicator.title = 'Manually edited';
                    }
                }
            });
        }

        if (sellPriceInput) {
            sellPriceInput.addEventListener('input', () => {
                if (sellPriceInput.value) {
                    sellPriceOverridden = true;
                    if (sellPriceIndicator) {
                        sellPriceIndicator.textContent = '‚úèÔ∏è';
                        sellPriceIndicator.title = 'Manually edited';
                    }
                }
            });
        }

        // Date validation setup
        function setupDateValidation() {
            if (!buyDateInput || !sellDateInput) return;
            
            // Set max date to today for both inputs
            const today = new Date().toISOString().split('T')[0];
            buyDateInput.setAttribute('max', today);
            sellDateInput.setAttribute('max', today);
            
            // Set initial min for sell date (if buy date is already set)
            if (buyDateInput.value) {
                sellDateInput.setAttribute('min', buyDateInput.value);
            }
            
            // When buy date changes, update sell date min and validate
            buyDateInput.addEventListener('change', () => {
                const buyDate = buyDateInput.value;
                
                // Validate date format
                if (buyDate && !/^\d{4}-\d{2}-\d{2}$/.test(buyDate)) {
                    showToast('Invalid date format', 'warning');
                    buyDateInput.value = '';
                    return;
                }
                
                if (buyDate) {
                    // Set sell date minimum to buy date
                    sellDateInput.setAttribute('min', buyDate);
                    
                    // If sell date is before buy date, clear it
                    if (sellDateInput.value && sellDateInput.value < buyDate) {
                        sellDateInput.value = '';
                        if (sellPriceInput) sellPriceInput.value = '';
                        if (sellPriceIndicator) {
                            sellPriceIndicator.textContent = 'üîÑ';
                            sellPriceIndicator.title = 'Auto-fetch';
                        }
                    }
                } else {
                    // Remove min constraint if buy date is cleared
                    sellDateInput.removeAttribute('min');
                }
                
                // Trigger price fetch
                clearTimeout(priceFetchTimer);
                priceFetchTimer = setTimeout(fetchPricesForDates, 500);
            });
            
            // When sell date changes, validate it's not before buy date
            sellDateInput.addEventListener('change', () => {
                const sellDate = sellDateInput.value;
                const buyDate = buyDateInput.value;
                
                // Validate date format
                if (sellDate && !/^\d{4}-\d{2}-\d{2}$/.test(sellDate)) {
                    showToast('Invalid date format', 'warning');
                    sellDateInput.value = '';
                    return;
                }
                
                if (sellDate && buyDate && sellDate < buyDate) {
                    showToast('Sell date must be after buy date', 'warning');
                    sellDateInput.value = '';
                    if (sellPriceInput) sellPriceInput.value = '';
                    if (sellPriceIndicator) {
                        sellPriceIndicator.textContent = 'üîÑ';
                        sellPriceIndicator.title = 'Auto-fetch';
                    }
                    return;
                }
                
                // Trigger price fetch
                clearTimeout(priceFetchTimer);
                priceFetchTimer = setTimeout(fetchPricesForDates, 500);
            });
        }

        async function fetchPricesForDates() {
            if (!calcTickerInput || !buyDateInput || !sellDateInput) return;

            const ticker = calcTickerInput.value.trim();
            const buyDate = buyDateInput.value;
            const sellDate = sellDateInput.value;

            if (!ticker || !buyDate || !sellDate) return;

            if (buyPriceIndicator) {
                buyPriceIndicator.textContent = 'üîÑ';
                buyPriceIndicator.title = 'Fetching...';
            }
            if (sellPriceIndicator) {
                sellPriceIndicator.textContent = 'üîÑ';
                sellPriceIndicator.title = 'Fetching...';
            }

            try {
                const response = await fetch(`${API_BASE}/api/chart/${encodeURIComponent(ticker)}?period=2y`);
                if (!response.ok) throw new Error('Failed to fetch prices');

                const data = await response.json();
                const candles = data.candles;

                const buyCandle = candles.find(c => c.time >= buyDate) || candles[0];
                const sellCandle = candles.slice().reverse().find(c => c.time <= sellDate) || candles[candles.length - 1];

                if (!buyPriceOverridden && buyPriceInput && buyCandle) {
                    buyPriceInput.value = buyCandle.close.toFixed(2);
                    if (buyPriceIndicator) {
                        buyPriceIndicator.textContent = '‚úì';
                        buyPriceIndicator.title = 'Auto-fetched';
                    }
                }

                if (!sellPriceOverridden && sellPriceInput && sellCandle) {
                    sellPriceInput.value = sellCandle.close.toFixed(2);
                    if (sellPriceIndicator) {
                        sellPriceIndicator.textContent = '‚úì';
                        sellPriceIndicator.title = 'Auto-fetched';
                    }
                }

            } catch (error) {
                console.error('Price fetch error:', error);
                if (buyPriceIndicator) {
                    buyPriceIndicator.textContent = '‚ùå';
                    buyPriceIndicator.title = 'Failed to fetch';
                }
                if (sellPriceIndicator) {
                    sellPriceIndicator.textContent = '‚ùå';
                    sellPriceIndicator.title = 'Failed to fetch';
                }
            }
        }

        // Calculate button handler
        if (calculateBtn) {
            calculateBtn.addEventListener('click', async () => {
                const ticker = calcTickerInput?.value.trim();
                const buyDate = buyDateInput?.value;
                const sellDate = sellDateInput?.value;
                const quantity = parseInt(quantitySelect?.value || 1);
                const buyPrice = buyPriceInput?.value ? parseFloat(buyPriceInput.value) : null;
                const sellPrice = sellPriceInput?.value ? parseFloat(sellPriceInput.value) : null;
                const buyFxRate = parseFloat(document.getElementById('buy-fx-rate')?.value || 0);
                const sellFxRate = parseFloat(document.getElementById('sell-fx-rate')?.value || 0);

                if (!ticker) {
                    showToast('Please enter a stock ticker', 'warning');
                    return;
                }
                if (!buyDate || !sellDate) {
                    showToast('Please select both buy and sell dates', 'warning');
                    return;
                }
                if (!buyFxRate || !sellFxRate) {
                    showToast('Please enter both FX rates (USDTHB)', 'warning');
                    return;
                }
                if (buyDate >= sellDate) {
                    showToast('Sell date must be after buy date', 'warning');
                    return;
                }

                setButtonLoading(calculateBtn, true);

                try {
                    const response = await fetch(`${API_BASE}/api/calculate-return`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            ticker, buy_date: buyDate, sell_date: sellDate, quantity,
                            buy_price: buyPrice, sell_price: sellPrice,
                            buy_fx_rate: buyFxRate, sell_fx_rate: sellFxRate
                        })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Calculation failed');
                    }

                    const data = await response.json();
                    displayCalculationResults(data);
                    if (calculatorResults) calculatorResults.classList.add('visible');
                    showToast('Calculation complete', 'success');

                } catch (error) {
                    showToast(error.message, 'error');
                    console.error('Calculate error:', error);
                } finally {
                    setButtonLoading(calculateBtn, false);
                }
            });
        }

        // Calculator Chart
        let calcChart = null;
        let calcLineSeries = null;

        async function renderCalculatorChart(calcData) {
            const chartContainer = document.getElementById('calculator-chart');
            if (!chartContainer || !window.LightweightCharts) return;

            // Reset container content if needed (but keep if it's the canvas)
            // If chart exists, we reuse it. If container has text (loading/error), we clear it.
            if (!calcChart) {
                chartContainer.innerHTML = ''; 
            }

            // Determine suitable period based on buy date
            // Default to 1y, but extend if buy date is older
            const buyDate = new Date(calcData.buyDate);
            const today = new Date();
            const yearsDiff = (today - buyDate) / (1000 * 60 * 60 * 24 * 365);
            
            // Build period fallback list - try longer periods first, fallback to shorter
            let periods = [];
            if (yearsDiff > 5) periods = ['max', '5y', '2y', '1y'];
            else if (yearsDiff > 2) periods = ['5y', '2y', '1y'];
            else if (yearsDiff > 1) periods = ['2y', '1y'];
            else periods = ['1y'];
            
            // Show loading if creating new chart or if we want to indicate activity
            if (!calcChart) {
                chartContainer.innerHTML = '<div class="chart-loading">Loading chart data...</div>';
            }

            let chartData = null;
            let lastError = null;
            let successfulPeriod = null;

            // Try periods in order until one succeeds
            for (const period of periods) {
                try {
                    const response = await fetch(`${API_BASE}/api/chart/${encodeURIComponent(calcData.ticker)}?period=${period}`);
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || `Failed to load chart data (${response.status})`);
                    }
                    
                    const data = await response.json();
                    
                    // Validate data exists
                    if (!data.candles || !Array.isArray(data.candles) || data.candles.length === 0) {
                        throw new Error(`No data available for period ${period}`);
                    }
                    
                    chartData = data;
                    successfulPeriod = period;
                    break; // Success, exit loop
                    
                } catch (error) {
                    lastError = error;
                    console.warn(`Chart fetch failed for period ${period}:`, error.message);
                    // Continue to next period
                }
            }

            // If all periods failed, show error
            if (!chartData) {
                console.error('Calc chart error (all periods failed):', lastError);
                let errorMsg = '‚ö†Ô∏è Chart unavailable';
                if (lastError) {
                    if (lastError.message.includes('404') || lastError.message.includes('No data')) {
                        errorMsg = '‚ö†Ô∏è No historical data available for this ticker';
                    } else if (lastError.message.includes('500')) {
                        errorMsg = '‚ö†Ô∏è Server error loading chart data';
                    } else {
                        errorMsg = `‚ö†Ô∏è ${lastError.message}`;
                    }
                }
                chartContainer.innerHTML = `<div class="chart-loading">${errorMsg}</div>`;
                calcChart = null; // Reset so we try again next time
                return;
            }
            
            // Clear loading text if it was just added
            if (!calcChart && chartContainer.querySelector('.chart-loading')) {
                chartContainer.innerHTML = '';
            }
            
            // Initialize chart if not exists
            if (!calcChart) {
                // Use calculator theme colors
                const isLight = document.body.classList.contains('light-mode');
                const textColor = isLight ? '#333333' : '#a0a0b0';
                
                calcChart = LightweightCharts.createChart(chartContainer, {
                    layout: {
                        background: { type: 'solid', color: 'transparent' }, 
                        textColor: textColor,
                    },
                    grid: {
                        vertLines: { color: 'rgba(212, 162, 127, 0.1)' },
                        horzLines: { color: 'rgba(212, 162, 127, 0.1)' },
                    },
                    width: chartContainer.clientWidth,
                    height: 320,
                    timeScale: {
                        borderColor: 'rgba(212, 162, 127, 0.2)',
                        timeVisible: true,
                    },
                    rightPriceScale: {
                        borderColor: 'rgba(212, 162, 127, 0.2)',
                    },
                    handleScroll: { vertTouchDrag: false },
                });

                calcLineSeries = calcChart.addAreaSeries({
                    topColor: 'rgba(212, 162, 127, 0.5)',
                    bottomColor: 'rgba(212, 162, 127, 0.05)',
                    lineColor: 'rgba(212, 162, 127, 1)',
                    lineWidth: 2,
                });
                
                // Handle resize
                const resizeObserver = new ResizeObserver(entries => {
                     if (entries.length === 0 || !entries[0].contentRect) return;
                     const { width } = entries[0].contentRect;
                     if (calcChart) calcChart.applyOptions({ width });
                });
                resizeObserver.observe(chartContainer);
            }

            // Prepare data with safety checks
            const areaData = chartData.candles
                .filter(c => c && c.time && typeof c.close === 'number' && !isNaN(c.close))
                .map(c => ({
                    time: c.time,
                    value: c.close
                }))
                .sort((a, b) => new Date(a.time) - new Date(b.time)); // Ensure sorted
            
            // Final safety check
            if (!areaData || areaData.length === 0) {
                console.error('No valid data points after filtering');
                chartContainer.innerHTML = '<div class="chart-loading">‚ö†Ô∏è No valid chart data available</div>';
                calcChart = null;
                return;
            }
            
            try {
                calcLineSeries.setData(areaData);
                
                // Find valid marker dates (closest available in data)
                // Data is sorted by time ascending
                const findClosest = (targetStr) => {
                    const target = new Date(targetStr).getTime();
                    if (isNaN(target)) return null;
                    
                    let best = null;
                    let minDiff = Infinity;
                    
                    for (const p of areaData) {
                        const pt = new Date(p.time).getTime();
                        if (isNaN(pt)) continue;
                        const diff = Math.abs(pt - target);
                        if (diff < minDiff) {
                            minDiff = diff;
                            best = p.time;
                        }
                    }
                    return best;
                };

                const buyTime = findClosest(calcData.buyDate);
                const sellTime = findClosest(calcData.sellDate);
                
                // Add markers
                const markers = [];
                
                if (buyTime) {
                    markers.push({
                        time: buyTime,
                        position: 'belowBar',
                        color: '#22c55e', 
                        shape: 'arrowUp',
                        text: `Buy @ $${calcData.calculations.buyPrice.toLocaleString()}`
                    });
                }
                
                if (sellTime) {
                    markers.push({
                        time: sellTime,
                        position: 'aboveBar',
                        color: '#ef4444', 
                        shape: 'arrowDown',
                        text: `Sell @ $${calcData.calculations.sellPrice.toLocaleString()}`
                    });
                }
                
                calcLineSeries.setMarkers(markers);
                
                // Fit content to show slightly more than the trade period
                calcChart.timeScale().fitContent();
                
            } catch (error) {
                console.error('Error rendering chart data:', error);
                chartContainer.innerHTML = '<div class="chart-loading">‚ö†Ô∏è Error rendering chart</div>';
                calcChart = null;
            }
        }

        function displayCalculationResults(data) {
            if (!calcResultsContent || !calcResultsTitle || !calcTimestamp) return;

            // Cleanup existing chart if any
            if (calcChart) {
                try {
                    calcChart.remove();
                } catch(e) { console.warn('Chart cleanup error', e); }
                calcChart = null;
                calcLineSeries = null;
            }

            const calc = data.calculations;
            const isPositiveUSD = calc.returnUSD >= 0;
            const isPositiveTHB = calc.returnTHB >= 0;
            const isPositiveFX = calc.fxImpactTHB >= 0;

            calcResultsTitle.textContent = data.ticker + ' - ' + data.displayName;
            calcTimestamp.textContent = new Date(data.timestamp).toLocaleString();
            calcResultsContent.textContent = '';

            // Position Summary
            const summary = createElementWithText('div', '', 'calc-summary');
            const summaryTitle = createElementWithText('h5', 'Position Summary');
            const summaryLine1 = createElementWithText('p', '');
            const tickerBold = createElementWithText('strong', data.ticker);
            summaryLine1.appendChild(tickerBold);
            summaryLine1.appendChild(document.createTextNode(' (' + data.displayName + ') ‚Ä¢ ' + data.quantity + ' shares'));
            const summaryLine2 = createElementWithText('p', data.buyDate + ' ‚Üí ' + data.sellDate);
            summary.appendChild(summaryTitle);
            summary.appendChild(summaryLine1);
            summary.appendChild(summaryLine2);
            calcResultsContent.appendChild(summary);

            // Values Table
            const tableDiv = createElementWithText('div', '', 'calc-values-table');
            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const theadRow = document.createElement('tr');
            theadRow.appendChild(createElementWithText('th', 'Currency'));
            theadRow.appendChild(createElementWithText('th', 'Buy Value'));
            theadRow.appendChild(createElementWithText('th', 'Sell Value'));
            thead.appendChild(theadRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            const usdRow = document.createElement('tr');
            usdRow.appendChild(createElementWithText('td', 'USD'));
            usdRow.appendChild(createElementWithText('td', '$' + calc.buyValueUSD.toLocaleString()));
            usdRow.appendChild(createElementWithText('td', '$' + calc.sellValueUSD.toLocaleString()));
            tbody.appendChild(usdRow);

            const thbRow = document.createElement('tr');
            thbRow.appendChild(createElementWithText('td', 'THB (' + data.buyFxRate.toFixed(2) + ' ‚Üí ' + data.sellFxRate.toFixed(2) + ')'));
            thbRow.appendChild(createElementWithText('td', '‡∏ø' + calc.buyValueTHB.toLocaleString()));
            thbRow.appendChild(createElementWithText('td', '‡∏ø' + calc.sellValueTHB.toLocaleString()));
            tbody.appendChild(thbRow);

            table.appendChild(tbody);
            tableDiv.appendChild(table);
            calcResultsContent.appendChild(tableDiv);

            // Returns Section
            const returns = createElementWithText('div', '', 'calc-returns');
            returns.appendChild(createElementWithText('h5', 'Returns'));

            // USD Return
            const usdReturn = createElementWithText('div', '', 'return-item');
            usdReturn.appendChild(createElementWithText('span', 'USD Return:'));
            const usdValue = createElementWithText('strong',
                (isPositiveUSD ? '+' : '') + '$' + calc.returnUSD.toLocaleString() +
                ' (' + (isPositiveUSD ? '+' : '') + calc.returnPctUSD.toFixed(2) + '%)',
                isPositiveUSD ? 'positive' : 'negative'
            );
            usdReturn.appendChild(usdValue);
            returns.appendChild(usdReturn);

            // THB Return
            const thbReturn = createElementWithText('div', '', 'return-item');
            thbReturn.appendChild(createElementWithText('span', 'THB Return:'));
            const thbValue = createElementWithText('strong',
                (isPositiveTHB ? '+' : '') + '‡∏ø' + calc.returnTHB.toLocaleString() +
                ' (' + (isPositiveTHB ? '+' : '') + calc.returnPctTHB.toFixed(2) + '%)',
                isPositiveTHB ? 'positive' : 'negative'
            );
            thbReturn.appendChild(thbValue);
            returns.appendChild(thbReturn);

            // FX Impact
            const fxReturn = createElementWithText('div', '', 'return-item fx-impact');
            fxReturn.appendChild(createElementWithText('span', 'FX Impact:'));
            const fxValue = createElementWithText('strong',
                (isPositiveFX ? '+' : '') + '‡∏ø' + calc.fxImpactTHB.toLocaleString() +
                ' (' + (isPositiveFX ? '+' : '') + calc.fxImpactPct.toFixed(2) + '%)',
                isPositiveFX ? 'positive' : 'negative'
            );
            fxReturn.appendChild(fxValue);
            returns.appendChild(fxReturn);


            calcResultsContent.appendChild(returns);

            // Chart Section
            const chartWrapper = document.createElement('div');
            chartWrapper.id = 'calculator-chart-wrapper';
            chartWrapper.className = 'calc-chart-section';
            chartWrapper.innerHTML = `
                <h5 class="calc-chart-title">Performance Visualization</h5>
                <div id="calculator-chart" class="calc-chart-container">
                    <div class="chart-loading">Loading chart data...</div>
                </div>
            `;
            calcResultsContent.appendChild(chartWrapper);

            // Trigger chart render
            renderCalculatorChart(data);

            // Price override note
            if (data.buyPriceOverridden || data.sellPriceOverridden) {
                const note = createElementWithText('p', '‚ö†Ô∏è Price(s) manually edited', 'price-note');
                calcResultsContent.appendChild(note);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadCompanyTickers();
            loadQuickStats();
            setupDateValidation();
        });
    </script>
</body>
</html>

